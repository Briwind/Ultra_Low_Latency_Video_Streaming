/* This file should be replaced by element source generated by
 * gst-element-maker, or by your own source code.  To generate suitable
 * element source using gst-element-maker, run:
 *
 *   gst-element-maker  slicer BASE_CLASS
 *
 * Where BASE_CLASS is replaced by one of the base class templates,
 * such as basesrc, basetransform, audiofilter, videofilter2, etc.
 * Then copy the resulting gstslicer.c file over this file, and
 * gstslicer.h over gstslicer.h.
 */
/* The rest of this file is shim code to allow the project to compile */

/* GStreamer
 * Copyright (C) 2020 FIXME <fixme@example.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
 * Boston, MA 02110-1335, USA.
 */
/**
 *
 * The slicer element does FIXME stuff.
 *
 * <refsect2>
 * <title>Example launch line</title>
 * |[
 * gst-launch-1.0 -v fakesrc ! slicer ! FIXME ! fakesink
 * ]|
 * FIXME Describe what the pipeline does.
 * </refsect2>
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <gst/gst.h>
#include <gst/video/video.h>
#include <time.h>
#include <sys/time.h>

#include "gstslicer.h"
#include "config.h"

GST_DEBUG_CATEGORY_STATIC (gst_slicer_debug_category);
#define GST_CAT_DEFAULT gst_slicer_debug_category

#define gst_slicer_parent_class parent_class
G_DEFINE_TYPE (GstSlicer, gst_slicer, GST_TYPE_ELEMENT);

#define GST_TILE_NUMBER 6

int framenumber=0;

  struct timeval fpsstart,fpsend;

  double fpstime;
double realfps=0.0;


//clock waiting
GstClockID cached_clock_id;


/* class initialization */

/* prototypes */

static GstFlowReturn gst_slicer_sink_chain (GstPad *pad, GstObject * parent,GstBuffer *buffer);

static gboolean gst_slicer_sink_setcaps (GstSlicer *self, GstCaps *caps);

static GstStateChangeReturn
gst_slicer_change_state (GstElement * element, GstStateChange transition);

static gboolean gst_slicer_sink_event (GstPad *pad, GstObject * parent, GstEvent *event);

static gboolean gst_slicer_sink_query (GstPad *pad, GstObject * parent,GstQuery *query);


static void gst_slicer_set_property (GObject * object,
    guint property_id, const GValue * value, GParamSpec * pspec);

static void gst_slicer_get_property (GObject * object,
    guint property_id, GValue * value, GParamSpec * pspec);

static GstCaps *
gst_slicer_getcaps (GstPad * pad, GstObject * parent, GstCaps * filter);

static gboolean
gst_slicer_src_query (GstPad *pad, GstObject *parent, GstQuery *query);

enum
{
  PROP_0
};

/* pad templates */

static GstStaticPadTemplate gst_slicer_src_template =
GST_STATIC_PAD_TEMPLATE ("src_%u",
    GST_PAD_SRC,
    GST_PAD_SOMETIMES,
    GST_STATIC_CAPS ("video/x-raw,"
	"format=(string)" GST_VIDEO_FORMATS_ALL)
    );

static GstStaticPadTemplate gst_slicer_sink_template =
GST_STATIC_PAD_TEMPLATE ("sink",
    GST_PAD_SINK,
    GST_PAD_ALWAYS,
    GST_STATIC_CAPS ("video/x-raw,"
	"format=(string)" GST_VIDEO_FORMATS_ALL)
    );


static void
gst_slicer_finalize (GObject * obj)
{
  GstSlicer *self = GST_SLICER (obj);

  if (self->pending_events) {
    g_list_foreach (self->pending_events, (GFunc) gst_mini_object_unref, NULL);
    g_list_free (self->pending_events);
    self->pending_events = NULL;
  }

  G_OBJECT_CLASS (parent_class)->finalize (obj);
}

static void
gst_slicer_class_init (GstSlicerClass * klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);

  GST_DEBUG_CATEGORY_INIT (gst_slicer_debug_category, "slicer", 0,
  "debug category for slicer element");

  /* Setting up pads and setting metadata should be moved to
     base_class_init if you intend to subclass this class. */
  gst_element_class_add_static_pad_template (element_class,
      &gst_slicer_sink_template);
  gst_element_class_add_static_pad_template (element_class,
      &gst_slicer_src_template);

  gst_element_class_set_static_metadata (GST_ELEMENT_CLASS(klass),
      "An tiling plugin change", "Generic", "split one frame to nine tiles",
      "soyeon <fixme@example.com>");

  gobject_class->set_property = gst_slicer_set_property;
  gobject_class->get_property = gst_slicer_get_property;
  gobject_class->finalize = gst_slicer_finalize;

  element_class->change_state = GST_DEBUG_FUNCPTR (gst_slicer_change_state);

}

static void
gst_slicer_init (GstSlicer *self)
{

  gst_video_info_init (&self->video_info);

  self->sinkpad = gst_pad_new_from_static_template (&gst_slicer_sink_template,"sink");
  
  gst_pad_set_chain_function (self->sinkpad,
            GST_DEBUG_FUNCPTR(gst_slicer_sink_chain));
  gst_pad_set_event_function (self->sinkpad,
            GST_DEBUG_FUNCPTR(gst_slicer_sink_event));
  gst_pad_set_query_function (self->sinkpad,
            GST_DEBUG_FUNCPTR(gst_slicer_sink_query));
  gst_element_add_pad (GST_ELEMENT(self), self->sinkpad);

gettimeofday(&fpsstart,NULL);
  cached_clock_id=NULL;
}

typedef struct
{
  GstCaps *caps;
  GstPad *pad;
} CopyStickyEventsData;

static gboolean
copy_sticky_events (GstPad * pad, GstEvent ** event, gpointer user_data)
{
  CopyStickyEventsData *data = user_data;

  if (GST_EVENT_TYPE (*event) >= GST_EVENT_CAPS && data->caps) {
    gst_pad_set_caps (data->pad, data->caps);
    data->caps = NULL;
  }

  if (GST_EVENT_TYPE (*event) != GST_EVENT_CAPS)
    gst_pad_push_event (data->pad, gst_event_ref (*event));

  return TRUE;
}

//add extra src pads
static void
gst_slicer_add_new_pads (GstSlicer * self, GstCaps * caps)
{
  GstPad *pad;
  guint i;

  for (i = 0; i < GST_TILE_NUMBER ; i++) {
    gchar *name = g_strdup_printf ("src_%u", i);
    GstCaps *srccaps;
    GstVideoInfo info;
    GstVideoFormat format = GST_VIDEO_INFO_FORMAT (&self->video_info);
	  guint width=GST_VIDEO_INFO_WIDTH(&self->video_info);
	  guint height=GST_VIDEO_INFO_HEIGHT(&self->video_info);
    
    CopyStickyEventsData data;

    gst_video_info_init (&info);

    //set height of src pad to 1/(tile number) of sink pad
    gst_video_info_set_format (&info, format, width,height/GST_TILE_NUMBER);

    srccaps = gst_video_info_to_caps (&info);

    pad = gst_pad_new_from_static_template (&gst_slicer_src_template, name);
    g_free (name);

    gst_pad_use_fixed_caps (pad);
    gst_pad_set_query_function (pad,
        GST_DEBUG_FUNCPTR (gst_slicer_src_query));
    gst_pad_set_active (pad, TRUE);

    data.pad = pad;
    data.caps = srccaps;
    gst_pad_sticky_events_foreach (self->sinkpad, copy_sticky_events, &data);
    if (data.caps)
      gst_pad_set_caps (pad, data.caps);
    gst_element_add_pad (GST_ELEMENT (self), pad);
    self->srcpads = g_list_prepend (self->srcpads, gst_object_ref (pad));

    gst_caps_unref (srccaps);
  }

  gst_element_no_more_pads (GST_ELEMENT (self));
  self->srcpads = g_list_reverse (self->srcpads);
}

static gboolean
gst_slicer_set_pads_caps (GstSlicer * self, GstCaps * caps)
{
  GList *l;
  gint i;
  gboolean ret = TRUE;

  for (l = self->srcpads, i = 0; l; l = l->next, i++) {
    GstPad *pad = GST_PAD (l->data);
    GstCaps *srccaps;
    GstVideoInfo info;

    if (!gst_video_info_from_caps (&info, caps)) {
      ret = FALSE;
      continue;
    }

    srccaps = gst_video_info_to_caps (&info);

    gst_pad_set_caps (pad, srccaps);
    gst_caps_unref (srccaps);
  }
  return ret;
}

static void
gst_slicer_remove_pads (GstSlicer * self)
{
  GList *l;

  GST_INFO_OBJECT (self, "removing pads");

  for (l = self->srcpads; l; l = l->next) {
    GstPad *pad = GST_PAD (l->data);

    gst_element_remove_pad (GST_ELEMENT_CAST (self), pad);
    gst_object_unref (pad);
  }
  g_list_free (self->srcpads);
  self->srcpads = NULL;

  gst_caps_replace (&self->sinkcaps, NULL);
}

static gboolean
gst_slicer_sink_setcaps (GstSlicer *self, GstCaps *caps)
{
  GstCaps *srccaps;

  GST_ERROR_OBJECT (self, "got caps: %" GST_PTR_FORMAT, caps);

  if (!gst_video_info_from_caps (&self->video_info, caps))
    goto invalid_caps;

  GST_ERROR_OBJECT (self, "in setcapssink function, width : %d , height : %d ",GST_VIDEO_INFO_WIDTH (&self->video_info),GST_VIDEO_INFO_HEIGHT (&self->video_info));

  if (self->sinkcaps && !gst_caps_is_equal (caps, self->sinkcaps)) {
    GstVideoInfo old_info;

    gst_video_info_init (&old_info);
    if (!gst_video_info_from_caps (&old_info, self->sinkcaps))
      goto info_from_caps_failed;
  }

  gst_caps_replace (&self->sinkcaps, caps);

  /* Get srcpad caps */
  srccaps = gst_caps_copy (caps);

  /* If we already have pads, update the caps otherwise
   * add new pads */
  if (self->srcpads) {
    if (!gst_slicer_set_pads_caps (self, srccaps))
      goto set_caps_failed;
  } else {
    gst_slicer_add_new_pads (self, srccaps);
  }

  gst_caps_unref (srccaps);

  return TRUE;

cannot_change_caps:
  {
    GST_WARNING_OBJECT (self, "caps change from %" GST_PTR_FORMAT
        " to %" GST_PTR_FORMAT " not supported: channel number or channel "
        "positions change", self->sinkcaps, caps);
    return FALSE;
  }
unsupported_caps:
  {
    GST_ERROR_OBJECT (self, "caps not supported: %" GST_PTR_FORMAT, caps);
    return FALSE;
  }
invalid_caps:
  {
    GST_ERROR_OBJECT (self, "invalid caps");
    return FALSE;
  }
set_caps_failed:
  {
    GST_ERROR_OBJECT (self, "set_caps failed");
    gst_caps_unref (srccaps);
    return FALSE;
  }
info_from_caps_failed:
  {
    GST_ERROR_OBJECT (self, "coud not get info from caps");
    return FALSE;
  }

}

static GstCaps *
gst_slicer_getcaps (GstPad * pad, GstObject * parent, GstCaps * filter)
{
  GstSlicer *self = GST_SLICER (parent);
  GstCaps *ret;
  GstIterator *it;
  GstIteratorResult res;
  GValue v = G_VALUE_INIT;

  if (pad != self->sinkpad) {
    ret = gst_pad_get_current_caps (pad);
    if (ret) {
      if (filter) {
        GstCaps *tmp =
            gst_caps_intersect_full (filter, ret, GST_CAPS_INTERSECT_FIRST);
        gst_caps_unref (ret);
        ret = tmp;
      }
      return ret;
    }
}
/* Intersect all of our pad template caps with the peer caps of the pad
   * to get all formats that are possible up- and downstream.
   *
   * For the pad for which the caps are requested we don't remove the channel
   * informations as they must be in the returned caps and incompatibilities
   * will be detected here already
   */
  ret = gst_caps_new_any ();
  it = gst_element_iterate_pads (GST_ELEMENT_CAST (self));

  do {
    res = gst_iterator_next (it, &v);
    switch (res) {
      case GST_ITERATOR_OK:{
        GstPad *ourpad = GST_PAD (g_value_get_object (&v));
        GstCaps *peercaps = NULL, *ourcaps;
        GstCaps *templ_caps = gst_pad_get_pad_template_caps (ourpad);

        ourcaps = gst_caps_copy (templ_caps);
        gst_caps_unref (templ_caps);

        /* If the peer exists and has caps add them to the intersection,
         * otherwise assume that the peer accepts everything */
        if (peercaps) {
          GstCaps *intersection;
          GstCaps *oldret = ret;

          intersection = gst_caps_intersect (peercaps, ourcaps);

          ret = gst_caps_intersect (ret, intersection);
          gst_caps_unref (intersection);
          gst_caps_unref (peercaps);
          gst_caps_unref (oldret);
        } else {
          GstCaps *oldret = ret;

          ret = gst_caps_intersect (ret, ourcaps);
          gst_caps_unref (oldret);
        }
        gst_caps_unref (ourcaps);
        g_value_reset (&v);
        break;
      }
      case GST_ITERATOR_DONE:
        break;
      case GST_ITERATOR_ERROR:
        gst_caps_unref (ret);
        ret = gst_caps_new_empty ();
        break;
      case GST_ITERATOR_RESYNC:
        gst_caps_unref (ret);
        ret = gst_caps_new_any ();
        gst_iterator_resync (it);
        break;
    }
  } while (res != GST_ITERATOR_DONE && res != GST_ITERATOR_ERROR);
  g_value_unset (&v);
  gst_iterator_free (it);

  if (filter) {
    GstCaps *aux;

    aux = gst_caps_intersect_full (filter, ret, GST_CAPS_INTERSECT_FIRST);
    gst_caps_unref (ret);
    ret = aux;
  }

  GST_DEBUG_OBJECT (pad, "Intersected caps to %" GST_PTR_FORMAT, ret);

  return ret;

  }

static gboolean
gst_slicer_sink_event (GstPad *pad, GstObject *parent, GstEvent *event)
{
  gboolean ret;
  GstSlicer *self = GST_SLICER(parent);

  GST_DEBUG ("Got %s event on pad %s:%s", GST_EVENT_TYPE_NAME (event),
      GST_DEBUG_PAD_NAME (pad));

  switch (GST_EVENT_TYPE (event)) {
    case GST_EVENT_FLUSH_STOP:
    case GST_EVENT_FLUSH_START:
    case GST_EVENT_EOS:
      ret = gst_pad_event_default (pad, parent, event);
      break;
    case GST_EVENT_CAPS:
    {
      GstCaps *caps;

      gst_event_parse_caps (event, &caps);
      ret = gst_slicer_sink_setcaps (self, caps);
      gst_event_unref (event);
      break;
    }


    default:
      if (!self->srcpads && !GST_EVENT_IS_STICKY (event)) {
        /* Sticky events are copied when creating a new pad */
        GST_OBJECT_LOCK (self);
        self->pending_events = g_list_append (self->pending_events, event);
        GST_OBJECT_UNLOCK (self);
        ret = TRUE;
      } else {
        ret = gst_pad_event_default (pad, parent, event);
      }
      break;
  }

  return ret;
}

static gboolean
gst_slicer_sink_query (GstPad *pad, GstObject *parent ,GstQuery *query)
{
  gboolean res;

  switch (GST_QUERY_TYPE (query)) {
    case GST_QUERY_CAPS:{
      GstCaps *filter;
      GstCaps *caps;

      gst_query_parse_caps (query, &filter);
      caps = gst_slicer_getcaps (pad, parent, filter);
      gst_query_set_caps_result (query, caps);
      gst_caps_unref (caps);
      res = TRUE;
      break;
    }
    default:
      res = gst_pad_query_default (pad, parent, query);
      break;
  }
  return res;
}

static gboolean
gst_slicer_src_query (GstPad *pad, GstObject *parent, GstQuery *query)
{
  gboolean res;
  GstSlicer *self= GST_SLICER(parent);

  res = gst_pad_query_default (pad, parent, query);

    if (res && GST_QUERY_TYPE (query) == GST_QUERY_CAPS) {
    GstCaps *filter, *caps;

    gst_query_parse_caps (query, &filter);
    caps = gst_slicer_getcaps (pad, parent, filter);
    gst_query_set_caps_result (query, caps);
    gst_caps_unref (caps);
  }

  return res;

}

void
gst_slicer_set_property (GObject * object, guint property_id,
    const GValue * value, GParamSpec * pspec)
{
  GstSlicer *self = GST_SLICER (object);

  GST_DEBUG_OBJECT (self, "set_property");

  switch (property_id) {
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

void
gst_slicer_get_property (GObject * object, guint property_id,
    GValue * value, GParamSpec * pspec)
{
  GstSlicer *slicer = GST_SLICER (object);

  GST_DEBUG_OBJECT (slicer, "get_property");

  switch (property_id) {
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

  
  struct timeval start_point,end_point;

  double operating;

typedef struct p_args{
  GstPad *_pad;
  GstBuffer * _buf;
} ThreadArgs;

float sum=0;

//syd_push slice buffer to next plugin
void *process(void *args){

  GstPad * pad=(GstPad *)((ThreadArgs*)args)->_pad;
  GstBuffer * buf=((ThreadArgs*)args)->_buf;

  GstFlowReturn ret = GST_FLOW_OK;

  ret = gst_pad_push (pad,buf);

  if (ret == GST_FLOW_NOT_LINKED){ret = GST_FLOW_OK;}
  else if(ret >= 100){
        ret=GST_FLOW_OK;
  }
  else{ 
      GST_DEBUG ("push() failed, flow = %s", gst_flow_get_name (ret));}

  pthread_exit(NULL);
}

//syd_ split video into slices and push it to next plugin
static GstFlowReturn
gst_slicer_process (GstSlicer * self, GstBuffer * buf)
{
  GstFlowReturn ret = GST_FLOW_OK;
  guint pads_pushed = 0, buffers_allocated = 0;

  guint width=GST_VIDEO_INFO_WIDTH (&self->video_info);
  guint height=GST_VIDEO_INFO_HEIGHT (&self->video_info);
  guint bufsize = width*(height)*1/GST_TILE_NUMBER;

  guint i;
  GList *srcs;
  GstBuffer **buffers_out = g_new0 (GstBuffer *, GST_TILE_NUMBER);
  guint8 *in, *out;
  GstMapInfo read_info;

  GstPad *pads[GST_TILE_NUMBER];

  /** slicing start **/
  for(int i=0;i<GST_TILE_NUMBER;i++){
	buffers_out[i]=gst_buffer_copy_region(buf,GST_BUFFER_COPY_MEMORY, i * bufsize,bufsize );
        gst_buffer_copy_into (buffers_out[i], buf, GST_BUFFER_COPY_METADATA, 0,
          -1);
	gst_buffer_copy_into (buffers_out[i], buf, GST_BUFFER_COPY_TIMESTAMPS, 0,
          -1);
  }

  
  /** end slicing **/

  /** push start **/
  //syd_ push each slice to next plugin simultaneously by multithreading
  pthread_t threads[GST_TILE_NUMBER];
  ThreadArgs temp[GST_TILE_NUMBER];

  for(srcs = self->srcpads, i = 0; srcs; srcs = srcs->next, i++){
	temp[i]._pad=srcs->data;
	temp[i]._buf=buffers_out[i];
	pthread_create(&threads[i],NULL,process,(void *)&temp[i]);
  }


  pthread_join(threads[0],NULL);
  pthread_join(threads[1],NULL);
  pthread_join(threads[2],NULL);
  pthread_join(threads[3],NULL);
  pthread_join(threads[4],NULL);
  pthread_join(threads[5],NULL);
  /** end push **/

  /* wait clock instead of basesink */

  GstClockReturn rett;
  GstClock *clock;
  GstClockTime base_time;
  GstClockTime time=GST_BUFFER_TIMESTAMP(buf);
GstClockTimeDiff jitter = 0;

  
  if (G_UNLIKELY ((clock = GST_ELEMENT_CLOCK (self)) == NULL)){
GST_ERROR_OBJECT(self,"no clock");}

 
  base_time = GST_ELEMENT_CAST (self)->base_time;

  time+=base_time;


  // Re-use existing clockid if available 
  // FIXME: Casting to GstClockEntry only works because the types
   // are the same 
  if (G_LIKELY (cached_clock_id != NULL
          && GST_CLOCK_ENTRY_CLOCK ((GstClockEntry *) cached_clock_id) == clock)) {
    if (!gst_clock_single_shot_id_reinit (clock, cached_clock_id,
            time)) {
      gst_clock_id_unref (cached_clock_id);
      cached_clock_id = gst_clock_new_single_shot_id (clock, time);
    }
  } else {
    if (cached_clock_id != NULL)
      gst_clock_id_unref (cached_clock_id);
   cached_clock_id = gst_clock_new_single_shot_id (clock, time);
  }

  rett = gst_clock_id_wait (cached_clock_id, &jitter);

GST_ERROR ("wait return, flow = %s", gst_flow_get_name (rett));

  /** end wait clock time instead of basesink **/

done:
  framenumber++;
  gst_buffer_unref (buf);
  g_free (buffers_out);

  return ret;

alloc_buffer_failed:
  {
    GST_WARNING ("gst_pad_alloc_buffer() returned %s", gst_flow_get_name (ret));
    goto clean_buffers;

  }
alloc_buffer_bad_size:
  {
    GST_WARNING ("called alloc_buffer(), but didn't get requested bytes");
    ret = GST_FLOW_NOT_NEGOTIATED;
    goto clean_buffers;
  }
push_failed:
  {
    GST_DEBUG ("push() failed, flow = %s", gst_flow_get_name (ret));
    goto clean_buffers;
  }
clean_buffers:
  {
    g_free (buffers_out);
    return ret;
  }
}

static GstFlowReturn
gst_slicer_sink_chain (GstPad *pad, GstObject * parent ,GstBuffer *buffer)
{

  double operating;
 
  GstSlicer *self = GST_SLICER (parent);
  GstFlowReturn ret;

  g_return_val_if_fail (GST_VIDEO_INFO_WIDTH (&self->video_info) > 0,
      GST_FLOW_NOT_NEGOTIATED);
  g_return_val_if_fail (GST_VIDEO_INFO_HEIGHT (&self->video_info) > 0,
      GST_FLOW_NOT_NEGOTIATED);


  ret = gst_slicer_process (self, buffer);

  if (ret != GST_FLOW_OK)
    GST_DEBUG_OBJECT (self, "flow return: %s", gst_flow_get_name (ret));

  return ret;
}


static GstStateChangeReturn
gst_slicer_change_state (GstElement * element, GstStateChange transition)
{
  g_return_val_if_fail (GST_IS_SLICER (element), GST_STATE_CHANGE_FAILURE);

  GstSlicer *self = GST_SLICER(element);
  GstStateChangeReturn ret;

  switch (transition) {
    case GST_STATE_CHANGE_NULL_TO_READY:
      break;
    case GST_STATE_CHANGE_READY_TO_PAUSED:
      break;
    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
      break;
    default:
      break;
  }

  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);

    switch (transition) {
    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
      break;
    case GST_STATE_CHANGE_PAUSED_TO_READY:
      gst_slicer_remove_pads (self);

      if (self->pending_events) {
        g_list_foreach (self->pending_events, (GFunc) gst_mini_object_unref,
            NULL);
        g_list_free (self->pending_events);
        self->pending_events = NULL;
      }
      break;
    case GST_STATE_CHANGE_READY_TO_NULL:
      break;
    default:
      break;
  }
  return ret;

}


static gboolean
plugin_init (GstPlugin * plugin)
{
  if(!gst_element_register (plugin, "slicer", GST_RANK_NONE,
      GST_TYPE_SLICER)) return FALSE;

  return TRUE;
}

#ifndef VERSION
#define VERSION "0.0.0"
#endif
#ifndef PACKAGE
#define PACKAGE "FIXME_package"
#endif
#ifndef PACKAGE_NAME
#define PACKAGE_NAME "FIXME_package_name"
#endif
#ifndef GST_PACKAGE_ORIGIN
#define GST_PACKAGE_ORIGIN "http://FIXME.org/"
#endif

GST_PLUGIN_DEFINE (
    GST_VERSION_MAJOR,
    GST_VERSION_MINOR,
    slicer,
    "split frame to slice by sy in plugin.c change",
    plugin_init,
    VERSION,
    "LGPL", PACKAGE_NAME, GST_PACKAGE_ORIGIN
)
